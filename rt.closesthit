#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_ray_tracing_position_fetch : require
#extension GL_EXT_buffer_reference : require

#include "common.glsl"
#define VIEW_DEPENDENT_LIGHTING
#include "../brdf.glsl"
#include "../lights.glsl"

#define MAX_REFLECTION_DEPTH 2

layout(set = 0, binding = 0) uniform texture2D kTextures2D[];
layout(set = 0, binding = 1) uniform sampler kSamplers[];
layout(set = 0, binding = 2, rgba16f) uniform image2D kTextures2DInOutF16[];
layout(set = 0, binding = 4) uniform accelerationStructureEXT kTLAS[];

vec4 textureBindless2D(uint textureid, uint samplerid, vec2 uv) {
    return texture(nonuniformEXT(sampler2D(kTextures2D[textureid], kSamplers[samplerid])), uv);
}

layout(push_constant) uniform PushConstants {
    uint tlas;
    uint skyboxTexture;
    uint outputTexture;
    uint firstHitTexture;
    uint secondHitTexture;
    uint velocityTexture;
    CameraBuffer camera;
    TransformsBuffer transforms;
    PrevTransformsBuffer prevTransforms;
    InstanceDataBuffer instanceData;
    VertexBuffer vertexBuffer;
    IndexBuffer indexBuffer;
    MaterialBuffer materials;
    LightsBuffer lights;
    PointLightsBuffer pointLights;
} pc;

mat3 cotangentFrame(vec3 N, vec3 edge1, vec3 edge2, vec2 deltaUV1, vec2 deltaUV2) {
    float denom = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
    if (abs(denom) < 0.0001) {
        vec3 T = normalize(edge1);
        vec3 B = cross(N, T);
        return mat3(T, B, N);
    }

    float f = 1.0 / denom;
    vec3 T = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);
    vec3 B = f * (-deltaUV2.x * edge1 + deltaUV1.x * edge2);

    // Re-orthogonalize
    T = normalize(T - dot(T, N) * N);
    B = cross(N, T);

    return mat3(T, B, N);
}

vec3 perturbNormal(vec3 N, vec3 normalSample, vec3 edge1, vec3 edge2, vec2 deltaUV1, vec2 deltaUV2) {
    vec3 map = normalize(2.0 * normalSample - vec3(1.0));
    mat3 TBN = cotangentFrame(N, edge1, edge2, deltaUV1, deltaUV2);
    return normalize(TBN * map);
}

layout(location = 0) rayPayloadInEXT RayPayload payload;
layout(location = 1) rayPayloadEXT bool isShadowed;
hitAttributeEXT vec2 attribs;

// Poisson Disk samples for PCF
vec2 poissonDisk[16] = vec2[](
    vec2(-0.94201624, -0.39906216), vec2( 0.94558609, -0.76890725),
    vec2(-0.09418410, -0.92938870), vec2( 0.34495938,  0.29387760),
    vec2(-0.91588581,  0.45771432), vec2(-0.81544232, -0.87912464),
    vec2(-0.38277543,  0.27676845), vec2( 0.97484398,  0.75648379),
    vec2( 0.44323325, -0.97511554), vec2( 0.53742981, -0.47373420),
    vec2(-0.26496911, -0.41893023), vec2( 0.79197514,  0.19090188),
    vec2(-0.24188840,  0.99706507), vec2(-0.81409955,  0.91437590),
    vec2( 0.19984126,  0.78641367), vec2( 0.14383161, -0.14100790)
);

// Adpated from: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
float random(vec2 co) {
    float a  = 12.9898;
    float b  = 78.233;
    float c  = 43758.5453;
    float dt = dot(co.xy ,vec2(a,b));
    float sn = mod(dt, 3.14);
    return fract(sin(sn) * c);
}

const float SHADOW_TMIN = 0.01;
const float SHADOW_TMAX = 10000.0;
const float REFLECTION_TMIN = 0.001;
const float REFLECTION_TMAX = 10000.0;

vec3 offsetRay(vec3 p, vec3 n) {
    return p + n * 0.001;
}

// Trace shadow ray, returns 1.0 if lit, 0.0 if in shadow
float traceShadowRay(vec3 origin, vec3 direction, float tmin, float tmax) {
    isShadowed = true;
    traceRayEXT(kTLAS[pc.tlas],
        gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT | gl_RayFlagsOpaqueEXT,
        0xff, 0, 0, 0,
        origin, tmin, direction, tmax, 1);
    return isShadowed ? 0.0 : 1.0;
}

// Directional light shadow with PCF
float calcDirLightShadow(vec3 shadowOrigin, vec3 lightDir, vec3 worldPos) {
    // Build orthonormal basis around light direction
    vec3 right = cross(lightDir, vec3(0.0, 1.0, 0.0));
    if (length(right) < 0.001) {
        right = cross(lightDir, vec3(1.0, 0.0, 0.0));
    }
    right = normalize(right);
    vec3 up = cross(right, lightDir);

    // Rotate kernel per-pixel
    float noise = random(worldPos.xy + worldPos.z);
    float angle = noise * 2.0 * PI;
    float s = sin(angle);
    float c = cos(angle);

    float visibility = 0.0;
    float diskRadius = 0.005;
    int samples = 2;

    for (int i = 0; i < samples; i++) {
        vec2 offset;
        offset.x = c * poissonDisk[i].x - s * poissonDisk[i].y;
        offset.y = s * poissonDisk[i].x + c * poissonDisk[i].y;

        vec3 jitteredDir = normalize(lightDir + right * offset.x * diskRadius + up * offset.y * diskRadius);
        visibility += traceShadowRay(shadowOrigin, jitteredDir, SHADOW_TMIN, SHADOW_TMAX);
    }

    return visibility / float(samples);
}

// Point light shadow with PCF
float calcPointLightShadow(vec3 shadowOrigin, vec3 lightPos, vec3 worldPos) {
    vec3 toLight = lightPos - shadowOrigin;
    float shadowDist = length(toLight);
    vec3 shadowDir = toLight / shadowDist;

    // Build orthonormal basis around shadow direction
    vec3 right = cross(shadowDir, vec3(0.0, 1.0, 0.0));
    if (length(right) < 0.001) {
        right = cross(shadowDir, vec3(1.0, 0.0, 0.0));
    }
    right = normalize(right);
    vec3 up = cross(right, shadowDir);

    // Rotate kernel per-pixel
    float noise = random(worldPos.xy + worldPos.z);
    float angle = noise * 2.0 * PI;
    float s = sin(angle);
    float c = cos(angle);

    float visibility = 0.0;
    float diskRadius = 0.02;
    int samples = 4;

    for (int i = 0; i < samples; i++) {
        vec2 offset;
        offset.x = c * poissonDisk[i].x - s * poissonDisk[i].y;
        offset.y = s * poissonDisk[i].x + c * poissonDisk[i].y;

        vec3 jitteredDir = normalize(shadowDir + right * offset.x * diskRadius + up * offset.y * diskRadius);
        visibility += traceShadowRay(shadowOrigin, jitteredDir, SHADOW_TMIN, shadowDist - SHADOW_TMIN);
    }

    return visibility / float(samples);
}

// Directional light with ray-traced shadows
vec3 calcDirLight(DirectionalLight light, PBRInfo pbrInputs, vec3 worldPos, vec3 N, vec3 Ng) {
    if (light.intensity == 0.0) return vec3(0.0);

    vec3 L = normalize(-light.direction);
    float NdotL = max(dot(N, L), 0.0);
    if (NdotL <= 0.0) return vec3(0.0);

    vec3 radianceIn = light.color * light.intensity;

    vec3 shadowOrigin = offsetRay(worldPos, Ng);
    float visibility = calcDirLightShadow(shadowOrigin, L, worldPos);
    vec3 brdf = computeBRDF(pbrInputs, L, radianceIn);
    return brdf * visibility;
}

// Point light with ray-traced shadows
vec3 calcPointLight(PointLight light, PBRInfo pbrInputs, vec3 worldPos, vec3 N, vec3 Ng) {
    if (light.intensity == 0.0) return vec3(0.0);

    vec3 lightVec = light.position - worldPos;
    float distance = length(lightVec);
    vec3 L = lightVec / distance;

    // Attenuation
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * distance * distance);
    float factor = distance / light.shadowFar;
    float damping = clamp(1.0 - (factor * factor * factor * factor), 0.0, 1.0);
    attenuation *= damping * damping;

    // Early exit if light is too far or facing away
    float NdotL = max(dot(N, L), 0.0);
    if (NdotL <= 0.0 || attenuation <= 0.0) return vec3(0.0);

    vec3 radianceIn = light.color * light.intensity * attenuation;

    vec3 shadowOrigin = offsetRay(worldPos, Ng);
    float visibility = calcPointLightShadow(shadowOrigin, light.position, worldPos);
    vec3 brdf = computeBRDF(pbrInputs, L, radianceIn);
    return brdf * visibility;
}

void main() {
    // Save current recursion depth before any recursive traces modify it
    int currentDepth = payload.depth;

    uint instanceIndex = gl_InstanceCustomIndexEXT;
    RTInstanceData instData = pc.instanceData.instances[instanceIndex];

    // Get triangle indices
    uint baseIndex = instData.indexOffset + gl_PrimitiveID * 3;
    uint i0 = pc.indexBuffer.indices[baseIndex + 0];
    uint i1 = pc.indexBuffer.indices[baseIndex + 1];
    uint i2 = pc.indexBuffer.indices[baseIndex + 2];

    // Get vertices
    Vertex v0 = pc.vertexBuffer.vertices[instData.vertexOffset + i0];
    Vertex v1 = pc.vertexBuffer.vertices[instData.vertexOffset + i1];
    Vertex v2 = pc.vertexBuffer.vertices[instData.vertexOffset + i2];

    // Interpolate using barycentric coordinates
    vec3 baryCoords = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);
    vec2 texCoord = v0.texCoord * baryCoords.x + v1.texCoord * baryCoords.y + v2.texCoord * baryCoords.z;
    vec3 localNormal = v0.normal * baryCoords.x + v1.normal * baryCoords.y + v2.normal * baryCoords.z;

    // Compute triangle edges (needed for face normal and TBN)
    vec3 edge1 = v1.position - v0.position;
    vec3 edge2 = v2.position - v0.position;

    // Compute geometric face normal in object space, then transform to world space
    vec3 NgLocal = normalize(cross(edge1, edge2));
    vec3 Ng = normalize(mat3(gl_ObjectToWorldEXT) * NgLocal);

    // Compute world position
    vec3 worldPos = gl_WorldRayOriginEXT + gl_WorldRayDirectionEXT * gl_HitTEXT;

    // Get material
    MaterialData material = pc.materials.materials[instData.materialId];

    // Shading normal in object space
    vec3 N = normalize(localNormal);
    vec3 normalSample = textureBindless2D(material.normalTexture, material.textureSampler, texCoord).xyz;
    if (length(normalSample) > 0.5) {
        vec2 deltaUV1 = v1.texCoord - v0.texCoord;
        vec2 deltaUV2 = v2.texCoord - v0.texCoord;
        N = perturbNormal(N, normalSample, edge1, edge2, deltaUV1, deltaUV2);
    }
    // Transform shading normal to world space
    N = normalize(mat3(gl_ObjectToWorldEXT) * N);

    // Flip normals if backfacing
    if (dot(N, -gl_WorldRayDirectionEXT) < 0.0) {
        N = -N;
    }
    if (dot(Ng, -gl_WorldRayDirectionEXT) < 0.0) {
        Ng = -Ng;
    }

    // Input lighting data
    vec3 V = normalize(-gl_WorldRayDirectionEXT);
    vec3 R = reflect(-V, N);

    // Ensure reflection direction stays above the geometric surface
    // (prevents rays from going through the surface when N differs from Ng)
    if (dot(R, Ng) < 0.0) {
        R = normalize(R - 2.0 * dot(R, Ng) * Ng);
    }

    // Albedo
    vec4 baseColor = material.baseColor;
    if (material.baseColorTexture != 0) {
        baseColor = textureBindless2D(material.baseColorTexture, material.textureSampler, texCoord) * material.baseColorFactor;
    }
    vec3 albedo = baseColor.rgb;

    // Metallic and roughness properties
    float metallic, roughness;
    if (material.metalRoughnessCombined != 0) {
        vec4 mrSample = textureBindless2D(material.metallicTexture, material.textureSampler, texCoord);
        metallic = (material.metallicTexture == 0)  ? material.metallic  : mrSample.b;
        roughness = (material.metallicTexture == 0) ? material.roughness : mrSample.g;
    }
    else {
        metallic = (material.metallicTexture == 0)   ? material.metallic  : textureBindless2D(material.metallicTexture,  material.textureSampler, texCoord).r;
        roughness = (material.roughnessTexture == 0) ? material.roughness : textureBindless2D(material.roughnessTexture, material.textureSampler, texCoord).r;
    }
    metallic = material.metallicFactor * metallic;
    roughness = material.roughnessFactor * roughness;

    // Calculate reflectance at normal incidence
    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, metallic);

    PBRInfo pbrInputs = PBRInfo(N, V, R, albedo, metallic, roughness, F0);

    vec3 color = vec3(0.0);

    // Ambient light
    AmbientLight ambient = pc.lights.ambientLight;
    color += albedo * ambient.color * ambient.intensity;

    // Directional light
    DirectionalLight dirLight = pc.lights.directionalLight;
    color += calcDirLight(dirLight, pbrInputs, worldPos, N, Ng);

    // Point lights
    uint numPointLights = pc.lights.numPointLights;
    for (uint i = 0; i < numPointLights; i++) {
        PointLight light = pc.pointLights.lights[i];
        color += calcPointLight(light, pbrInputs, worldPos, N, Ng);
    }

    // Emissive
    vec3 emissive = material.emissiveFactor.rgb;
    if (material.emissiveTexture != 0) {
        emissive *= textureBindless2D(material.emissiveTexture, material.textureSampler, texCoord).rgb;
    }
    color += emissive;

    // Store hit data to output textures
    float linearDepth = clamp((gl_HitTEXT - pc.camera.near) / (pc.camera.far - pc.camera.near), 0.0, 1.0);
    ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy);
    if (currentDepth == 0) {
        // Primary ray hit
        imageStore(kTextures2DInOutF16[pc.firstHitTexture], pixelCoord, vec4(N, linearDepth));

        // Compute velocity for primary ray
        // Interpolate local position from vertices
        vec3 localPos = v0.position * baryCoords.x + v1.position * baryCoords.y + v2.position * baryCoords.z;

        // Current world position - use the ray-traced result (matches TLAS transform)
        vec4 currentWorldPos = vec4(worldPos, 1.0);

        // Previous world position - use previous transforms buffer
        mat4 prevModel = pc.prevTransforms.model[instData.transformIndex];
        vec4 prevWorldPos = prevModel * vec4(localPos, 1.0);

        // Project to clip space
        vec4 currentClipPos = pc.camera.viewProj * currentWorldPos;
        vec4 prevClipPos = pc.camera.prevViewProj * prevWorldPos;

        // Compute NDC positions
        vec2 currentNDC = currentClipPos.xy / currentClipPos.w;
        vec2 prevNDC = prevClipPos.xy / prevClipPos.w;

        // Compute velocities
        vec2 screenVelocity = (currentNDC - prevNDC) * 0.5;
        float currentViewZ = -currentClipPos.w;
        float prevViewZ = -prevClipPos.w;
        float depthVelocity = prevViewZ - currentViewZ;

        imageStore(kTextures2DInOutF16[pc.velocityTexture], pixelCoord, vec4(screenVelocity, depthVelocity, 1.0));
    }
    else if (currentDepth == 1) {
        // First reflection hit
        imageStore(kTextures2DInOutF16[pc.secondHitTexture], pixelCoord, vec4(N, linearDepth));
    }

    // Reflections
    if (currentDepth < MAX_REFLECTION_DEPTH && roughness < 1.0) {
        // Schlick Fresnel approximation using F0
        float NdotV = max(dot(N, V), 0.0);
        float F0_avg = (F0.r + F0.g + F0.b) / 3.0;
        float fresnel = F0_avg + (1.0 - F0_avg) * pow(1.0 - NdotV, 5.0);

        if (fresnel > 0.01) {
            vec3 reflectOrigin = offsetRay(worldPos, Ng);

            // Set up payload for reflection ray
            payload.color = vec3(0.0);
            payload.depth = currentDepth + 1;

            // Trace reflection ray
            traceRayEXT(kTLAS[pc.tlas],
                gl_RayFlagsOpaqueEXT,
                0xff, 0, 0, 0,
                reflectOrigin, REFLECTION_TMIN, R, REFLECTION_TMAX, 0);

            // Blend reflection based on Fresnel and roughness
            vec3 reflectedColor = payload.color;
            float reflectionStrength = fresnel * (1.0 - roughness);
            color = mix(color, reflectedColor, reflectionStrength);
        }
    }

    payload.color = color;
    payload.depth = currentDepth;
}
